# Создайте модуль и напишите в нём функцию, которая получает на вход дату в формате DD.MM.YYYY
# Функция возвращает истину, если дата может существовать или ложь, если такая дата невозможна.
# Для простоты договоримся, что год может быть в диапазоне [1, 9999].
# Весь период (1 января 1 года - 31 декабря 9999 года) действует Григорианский календарь.
# Проверку года на високосность вынести в отдельную защищённую функцию.
# В модуль с проверкой даты добавьте возможность запуска в терминале с передачей даты на проверку.

from sys import argv

def _check_leap_year(year: int) -> bool:
    """
    Функция проверяет год на високосность.
    Признаки:
    - Год, номер которого кратен 400, — високосный;
    - Остальные годы, номер которых кратен 100, — невисокосные (например, годы 1700, 1800, 1900, 2100, 2200, 2300);
    - Остальные годы, номер которых кратен 4, — високосные.
    - Все остальные годы — невисокосные.
    :param year: Проверяемый год
    :return: True - если год високосный, в противном случае - False
    """
    is_leap = False
    if year % 400 == 0:
        is_leap = True
    elif year % 4 == 0 and year % 100 != 0:
        is_leap = True

    return is_leap


def check_date(input_date: str) -> bool:
    """
    Функция проверяет правильность переданной даты.
    :param input_date: Проверяемая дата в строковом формате
    :return: True - если дата записана верно, в противном случае - False
    """
    data = None
    is_date_correct = True  # Флаг для определения правильности даты

    common_year_data = {
        1: 31,
        2: 28,
        3: 31,
        4: 30,
        5: 31,
        6: 30,
        7: 31,
        8: 31,
        9: 30,
        10: 31,
        11: 30,
        12: 31,
    }  # Данные по количеству дней в месяцах для невисокосного года
    leap_year_data = {
        1: 31,
        2: 29,
        3: 31,
        4: 30,
        5: 31,
        6: 30,
        7: 31,
        8: 31,
        9: 30,
        10: 31,
        11: 30,
        12: 31,
    }  # Данные по количеству дней в месяцах для високосного года

    # Первая проверка на соблюдение формата ввода
    # Проверяет что в качестве разделителей - две точки (иначе длина списка не будет равна 3-м)
    # а день, месяц и год записаны числами
    # Если проверка не выполняется - функция завершит работу с соответствующим сообщением
    try:
        data = [int(x) for x in input_date.split(".")]
        if len(data) != 3:
            raise Exception
    except ValueError:
        print("Invalid input. Please use this format 'DD.MM.YYYY'")
        return False

    # Проверяем лежит ли год в установленных диапазонах
    if data[2] < 1 or data[2] > 9999:
        is_date_correct = False
    else:
        # Если с годом все в порядке - проверяем его на високосность
        # В зависимости от результата проверки - обращаемся к нужному словарю,
        # содержащему количество дней для каждого месяца.
        # Если месяц введен неверно - ловим KeyError и функция завершает работу.
        # Иначе проверяем что введенный день лежит в диапазоне от 1 до максимального количества дней месяца.
        if _check_leap_year(data[2]):
            try:
                if leap_year_data[data[1]] < data[0] or data[0] < 1:
                    is_date_correct = False
            except KeyError:
                return False
        else:
            try:
                if common_year_data[data[1]] < data[0] or data[0] < 1:
                    is_date_correct = False
            except KeyError:
                return False

    return is_date_correct


if __name__ == "__main__":
    # Если запрос ввода от пользователя - расскомментировать строку ниже
    # user_date = input("Please, enter date to check (format: DD.MM.YYYY): ")

    # Если передача даты при запуске из терминала - используем строку ниже
    user_date = argv[1]

    # Оставляем эту строку для любого из случаев выше
    print("Correct date!") if check_date(user_date) else print("Invalid date.")
